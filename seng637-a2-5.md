**SENG 637 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group 5:       |
| -------------- |
| Student Names: |
| Lawrence       |
| Kwesi          |
| Joe            |
| Zhanzhi        |

# 1. Introduction

In this lab, we performed unit testing on the Range class and DataUtilities from the JFreeChart library. The Range class encapsulates a range of numeric values and provides several methods to query whether a value is contained within the range, calculate the length of the range, and determine the central value, upper, and lower bounds.

Additionally, we tested the DataUtilities class, which provides utility methods for managing and manipulating datasets in JFreeChart. Both classes are integral to handling numerical data and performing various range-based operations.

The primary objective of this testing was to ensure the correctness of the methods in both classes through Boundary Value Analysis (BVA) and Equivalence Class Partitioning (ECP). These methods were tested to confirm that each function behaves as expected across a variety of test cases, ensuring reliable and accurate functionality for data manipulation and range operations.

# 2. Detailed description of unit test strategy
Our testing strategy for the RangeTest class was based on ; 
- Equivalence Class Partitioning
- Boundary Value Analysis
- Robustness Testing (negative, zero, and large values)

## Range

The following functions of the Range class were tested: 

contains() - Checks if a given value is within the range. 

getLength() - Returns the length of the range. 

getCentralValue() - Returns the central value of the range. 

getUpperBound() - Returns the upper bound of the range. 

getLowerBound() - Returns the lower bound of the range. 

We applied BVA for testing the contains() method and boundary-specific tests for getLength(), getCentralValue(), getUpperBound(), and getLowerBound(). The domain for  Range class under test was from 1.0 to 5.0 unless otherwise specified in the tables. 

Several other domains were specified to cover other classes. 

### Equivalence Class Partitioning
  
The valid range is from 1 to 5. We defined the following equivalence classes for the contains() method: 

EC1 - Invalid (Below Lower Bound): Values less than 1. 

EC2 - Valid (Within Boundaries): Values between 1 and 5, inclusive. 

EC3 - Invalid (Above Upper Bound): Values greater than 5. 

#_Test Cases_

Function: **_contains()_**

| TC - ID | Input Value | Boundary            | Scenario Description                                                       | Expected Result | Test Outcome |
|---------|------------|--------------------|---------------------------------------------------------------------------|----------------|-------------|
| TC1     | 0.0        | Below Lower Bound  | Testing value just below the lower boundary of the range (1.0)           | False          | Pass        |
| TC2     | 3.0        | Inside Range       | Testing a value inside the valid range (between 1.0 and 5.0)             | True           | Pass        |
| TC3     | 1.0        | Lower Boundary     | Testing the lower boundary value of the range (1.0)                      | True           | Pass        |
| TC4     | 5.0        | Upper Boundary     | Testing the upper boundary value of the range (5.0)                      | True           | Pass        |
| TC5     | 6.0        | Above Upper Bound  | Testing value just above the upper boundary of the range (5.0)           | False          | Pass        |


Function: **_getLength()_**

| TC - ID | Range Start | Range End | Scenario Description                                                     | Expected Length | Test Outcome |
|:--------|:-----------:|:---------:|---------------------------------------------------------------------------|:---------------:|:------------:|
| TC1     | 1.0         | 5.0       | Standard range with equal start and end values                           | 4.0             | Pass         |
| TC2     | 1.0         | 1.1       | Small range with a tiny difference between the start and end             | 0.1             | Pass         |
| TC3     | 1.0         | 1000000.0 | Large range with a large difference between the start and end            | 999999.0        | Pass         |
| TC4     | 5.0         | 5.0       | Zero-length range (same start and end)                                   | 0.0             | Pass         |
| TC5     | -5.0        | 5.0       | Range spanning both negative and positive values                         | 10.0            | Pass         |


Function: **_getCentralValue()_**

| TC - ID | Range Start | Range End | Scenario Description                                                                 | Expected Central Value | Test Outcome |
|---------|------------|-----------|--------------------------------------------------------------------------------------|-----------------------|-------------|
| TC1     | 1.0        | 5.0       | Standard range with a well-defined central value                                   | 3.0                   | Pass        |
| TC2     | 1.0        | 1.1       | Very small range where central value is halfway between start and end              | 1.05                  | Pass        |
| TC3     | 5.0        | 5.0       | Zero-length range where the central value is just the value itself                 | 5.0                   | Pass        |
| TC4     | -5.0       | 5.0       | Range that spans both negative and positive values, central value should be zero   | 0.0                   | Pass        |
| TC5     | 1.0        | 1000000.0 | Very large range, central value should be the average of the start and end values  | 500000.5              | Pass        |
| TC6     | 5.0        | 1.0       | Reverse boundaries; central value should still be the average                      | Exception                  |Pass (Exception Expected)        |


Function: **_getUpperBound()_**
| TC - ID | Range Start | Range End | Scenario Description                                                          | Expected Upper Bound | Test Outcome |
|---------|------------|-----------|------------------------------------------------------------------------------|---------------------|-------------|
| TC1     | 1.0        | 5.0       | Standard range with the upper bound clearly defined                         | 5.0                 | Fail        |
| TC2     | 5.0        | 5.0       | Zero-length range where the upper bound is the same as the start value      | 5.0                 | Pass        |
| TC3     | -5.0       | 5.0       | Range spanning negative and positive values, upper bound should be 5        | 5.0                 | Fail        |
| TC4     | 1.0        | 1000000.0 | Very large range where the upper bound is 1000000                           | 1000000.0           | Fail        |
| TC5     | 5.0        | 1.0       | Reverse boundaries (invalid range where lower > upper)                      | Exception               | Pass (Exception Expected)        |

Function: **_getLowerBound()_**
| TC - ID | Range Start | Range End | Scenario Description                                      | Expected Lower Bound | Test Outcome |
|---------|------------|-----------|-----------------------------------------------------------|---------------------|-------------|
| TC1     | 1.0        | 5.0       | Standard range with the lower bound clearly defined      | 1.0                 | Pass        |
| TC2     | 5.0        | 5.0       | Zero-length range                                        | 5.0                 | Pass        |
| TC3     | -5.0       | 5.0       | Range spanning negative and positive values              | -5.0                | Pass        |
| TC4     | 1.0        | 1000000.0 | Very large range                                         | 1.0                 | Pass        |
| TC5     | 5.0        | 1.0       | Reverse boundaries (invalid input: lower > upper)        | Exception           | Pass (Exception Expected) |

#Test Case Summary 
contains(): All boundary and inside range tests passed as expected. The method correctly identified values that were outside the range, as well as those that were on the boundaries and inside. 

getLength(): The length was calculated correctly for typical ranges, as well as for small and large ranges. The edge case with zero-length ranges was also handled correctly. 

getCentralValue(): The central value calculation was correct across a variety of ranges, including those that span both negative and positive values. 

getLowerBound(): The tests confirmed that the Range class correctly returns the lower bounds of any valid range, including ranges where the upper and lower bounds are the same (zero-length ranges). 

getUpperBound(): 

The tests confirmed that the Range class does not always return the correct upper bound for certain ranges. Specifically, the method fails in some cases, as seen in test cases TC1, TC3, and TC4, where the expected upper bound was not returned correctly. 

Bug Analysis: Upon closer examination, it appears there is a bug in the getUpperBound() method. The method is expected to return the upper bound of a range as a double, but in some cases, particularly when dealing with large ranges or edge cases, the value is not being returned as expected. 

Potential Cause: The issue might be due to incorrect handling of certain edge cases or a rounding error when calculating the upper bound. It’s also possible that the method does not account for ranges with extreme values (like very large or small numbers). 

Example Failures: 

Test Case TC1 (range from 1.0 to 5.0): Expected upper bound is 5.0, but the method failed to return it correctly. 

Test Case TC3 (range from -5.0 to 5.0): Expected upper bound is 5.0, but the method failed to return it correctly. 

Test Case TC4 (range from 1.0 to 1000000.0): Expected upper bound is 1000000.0, but the method failed to return it correctly. 

Impact of the Bug: This bug affects the accuracy of any functionality that relies on the upper bound of a range. For instance, operations like checking whether a value is within the upper limit of a range, or adjusting the range dynamically, may not work as intended. 

Next Steps: It is important to address this bug by reviewing the method’s implementation. We recommend investigating the logic for handling large values and ensuring that the method returns the correct upper bound value across all test cases. A potential fix might involve improving how the method handles boundary conditions or implementing additional checks for large or small values. 

## DataUtilities

# 3 Test cases developed

Text…

// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

# 4 How the team work/effort was divided and managed

Our team of four divided the work by class: two members worked on testing the Range class and two on DataUtilities class. To stay on track with the assignment deadline we had regular meetings to know how best we are progressing , conducted peer reviews to ensure consistency and quality in our test cases.

## Work distribution
| Members           | Class/Focus        | Tasks                                                                 |
|------------------|------------------|-------------------------------------------------------------------------------|
| Zhanzi, Joe | DataUtilitiesTest          | Review the DataUtilities class in the Javadoc and use equivalence classes, boundary value analysis, and robustness testing to create black-box test cases for the 5 methods. Then, run the tests using JUnit and document the results and outcome of each test case. |
| Kwesi, Lawrence | RangeTest | Review the Rangeclass in the Javadoc and use equivalence classes, boundary value analysis, and robustness testing to create black-box test cases for 5 chosen methods. Then, run the tests using JUnit and document the results and outcome on each test case. |

# 5 Difficulties encountered, challenges overcome, and lessons learned
## The difficulties encountered
- When testing functions like getLength() and getCentralValue(), you need to provide a delta value in assertEquals to compare double values. Because of how Java stores floating-point numbers, some decimal values can't be saved exactly. Tests may not pass even if the implementation is right because of this. Choosing the right tolerance value (like 0.0001) makes sure to guarantee that minor rounding errors do not cause false test failures while still detecting real calculation issues.

 
 ## Challenges Overcome

 ## Lessons Learned
 -  We learnt out that it is necessary to test unusual cases, like zero-length ranges with or boundaries that go backwards, to make sure the program works in all situations.
 -  Organized Testing: Writing one clear test for each situation makes it easier to keep track of which test cases pass or fail.



# 6 Comments/feedback on the lab itself

The lab was well-structured and set up in a way to introduce us to JUnit for automated unit testing. The step-by-step instructions , which started out with setting up of the project , configuring the libraries and getting to know about the JFreeChart framework , made it easy for us to acquire some hands-on experience. Using Javadoc as a source of requirement enabled us to derive test cases from specifications which is essential in black-box testing.

This lab helped greatly to understand JUnit and unit testing procedures, with regard to organization and documentation of each test case's objective. We had to carefully examine each method's intended behaviour in order to write assertions with expeccted results. 
