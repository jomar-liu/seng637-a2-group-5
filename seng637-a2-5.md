**SENG 637 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group 5:       |
| -------------- |
| Student Names: |
| Lawrence       |
| Kwesi          |
| Joe            |
| Zhanzhi        |

# 1 Introduction

In this lab, we performed unit testing on the Range class and DataUtilities from the JFreeChart library. The Range class encapsulates a range of numeric values and provides several methods to query whether a value is contained within the range, calculate the length of the range, and determine the central value, upper, and lower bounds.

Additionally, we tested the DataUtilities class, which provides utility methods for managing and manipulating datasets in JFreeChart. Both classes are integral to handling numerical data and performing various range-based operations.

The primary objective of this testing was to ensure the correctness of the methods in both classes through Boundary Value Analysis (BVA) and Equivalence Class Partitioning (ECP). These methods were tested to confirm that each function behaves as expected across a variety of test cases, ensuring reliable and accurate functionality for data manipulation and range operations.

# 2 Detailed description of unit test strategy
Our testing strategy for the RangeTest class was based on ; 
- Equivalence Class Partitioning
- Boundary Value Analysis
- Robustness Testing (negative, zero, and large values)

The base range for testing the unit cases was given as 1 to 5.
The range provided the basis for creating valid, invalid, and boundary test scenarios.

- Equivalence Class Partitioning
  
Equivalence Class Partitoning(ECP) was used to categorize input values into groups as a way of verifying the systems behaviour for each of the  classes effectively.

The input domain for the contains( double value) method was categorized into three equivalence classes;
-  EC1 (Invalid Range – Below Lower Bound): value < 1
-  EC2 (Valid Range): 1 ≤ value ≤ 5
-  EC3 (Invalid – Above Upper Bound) value > 5

  We also checked the boundary values of 1.0 and 5.0 to make sure that the method includes the range's bounds. This helps find errors in how the program checks values.

For methods like getLength() and getCentralValue(), equivalence partitions were based on structural changes in the range itself instead of just one input value. These partitions included:
- Normal Valid Range
- Small Range
- Large Range
- Zero-length Range
- Negative to Positive Range
- Reverse Bounds
  

- Boundary Value Analysis: 
  We used Boundary Value Analysis to check for errors near the edge of the range. For the base range(1.0 , 5.0) we looked at the following boundary values;
  - Lower Boundary: 1.0
  - Upper Boundary: 5.0
  - Just Below Lower Boundary: 0.0
  - Just Above Upper Boundary: 6.0
    
These tests verify that the range includes both the lowest and highest values, excludes values beyond the range, and accurately assesses the boundaries. We also tested ranges when the lower and upper bounds are the same to make that the program runs when there is only one value in the range.

- Robustness Testing: We tested robustness with large numbers, minor decimal differences, zero-length ranges, negative-to-positive intervals, and reversed boundaries. These makes sure the program handles odd inputs without arithmetic or logic errors




# 3 Test cases developed

Text…

// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

# 4 How the team work/effort was divided and managed

Our team of four divided the work by class: two members worked on testing the Range class and two on DataUtilities class. To stay on track with the assignment deadline we had regular meetings to know how best we are progressing , conducted peer reviews to ensure consistency and quality in our test cases.

## Work distribution
| Members           | Class/Focus        | Tasks                                                                 |
|------------------|------------------|-------------------------------------------------------------------------------|
| Zhanzi, Joe | DataUtilitiesTest          | Review the DataUtilities class in the Javadoc and use equivalence classes, boundary value analysis, and robustness testing to create black-box test cases for the 5 methods. Then, run the tests using JUnit and document the results and outcome of each test case. |
| Kwesi, Lawrence | RangeTest | Review the Rangeclass in the Javadoc and use equivalence classes, boundary value analysis, and robustness testing to create black-box test cases for 5 chosen methods. Then, run the tests using JUnit and document the results and outcome on each test case. |

# 5 Difficulties encountered, challenges overcome, and lessons learned
## The difficulties encountered
- When testing functions like getLength() and getCentralValue(), you need to provide a delta value in assertEquals to compare double values. Because of how Java stores floating-point numbers, some decimal values can't be saved exactly. Tests may not pass even if the implementation is right because of this. Choosing the right tolerance value (like 0.0001) makes sure to guarantee that minor rounding errors do not cause false test failures while still detecting real calculation issues.

 
 ## Challenges Overcome

 ## Lessons Learned
 -  We learnt out that it is necessary to test unusual cases, like zero-length ranges with or boundaries that go backwards, to make sure the program works in all situations.
 -  Organized Testing: Writing one clear test for each situation makes it easier to keep track of which test cases pass or fail.



# 6 Comments/feedback on the lab itself

The lab was well-structured and set up in a way to introduce us to JUnit for automated unit testing. The step-by-step instructions , which started out with setting up of the project , configuring the libraries and getting to know about the JFreeChart framework , made it easy for us to acquire some hands-on experience. Using Javadoc as a source of requirement enabled us to derive test cases from specifications which is essential in black-box testing.

This lab helped greatly to understand JUnit and unit testing procedures, with regard to organization and documentation of each test case's objective. We had to carefully examine each method's intended behaviour in order to write assertions with expeccted results. 
