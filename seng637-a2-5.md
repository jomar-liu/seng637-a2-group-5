**SENG 637 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group 5:       |
| -------------- |
| Student Names: |
| Lawrence       |
| Kwesi          |
| Joe            |
| Zhanzhi        |

# 1. Introduction

In this lab, we performed unit testing on the Range class and DataUtilities from the JFreeChart library. The Range class encapsulates a range of numeric values and provides several methods to query whether a value is contained within the range, calculate the length of the range, and determine the central value, upper, and lower bounds.

Additionally, we tested the DataUtilities class, which provides utility methods for managing and manipulating datasets in JFreeChart. Both classes are integral to handling numerical data and performing various range-based operations.

The primary objective of this testing was to ensure the correctness of the methods in both classes through Boundary Value Analysis (BVA) and Equivalence Class Partitioning (ECP). These methods were tested to confirm that each function behaves as expected across a variety of test cases, ensuring reliable and accurate functionality for data manipulation and range operations.

# 2. Detailed description of unit test strategy
Our testing strategy for the RangeTest class was based on ; 
- Equivalence Class Partitioning
- Boundary Value Analysis
- Robustness Testing (negative, zero, and large values)

## Range

The following functions of the Range class were tested: 

contains() - Checks if a given value is within the range. 

getLength() - Returns the length of the range. 

getCentralValue() - Returns the central value of the range. 

getUpperBound() - Returns the upper bound of the range. 

getLowerBound() - Returns the lower bound of the range. 

We applied BVA for testing the contains() method and boundary-specific tests for getLength(), getCentralValue(), getUpperBound(), and getLowerBound(). The domain for  Range class under test was from 1.0 to 5.0 unless otherwise specified in the tables. Several other domains were specified to cover other classes. 
  

## Test Cases

## Method tested: **_contains()_**

### Equivalence Class Partitioning

The valid range is from 1 to 5. We defined the following equivalence classes for the contains() method: 

- EC1 - Invalid (Below Lower Bound): Values less than 1. 

- EC2 - Valid (Within Boundaries): Values between 1 and 5, inclusive. 

- EC3 - Invalid (Above Upper Bound): Values greater than 5. 

| TC - ID | Input Value | Boundary          |Partitions Covered | Scenario Description & Method                                                      | Expected Result | Test Outcome |
|---------|------------|--------------------|------------|---------------------------------------------------------------------------|----------------|-------------|
| TC1     | 0.0        | Below Lower Bound  | EC1        | Testing value just below the lower boundary of the range (1.0) <br> Method: testContainsBelowRange           | False          | Pass        |
| TC2     | 3.0        | Inside Range       | EC2        | Testing a value inside the valid range (between 1.0 and 5.0) <br> Method: testContainsInsideRange             | True           | Pass        |
| TC3     | 1.0        | Lower Boundary     | EC2        | Testing the lower boundary value of the range (1.0)  <br>  Method: testContainsLowerBoundary                   | True           | Pass        |
| TC4     | 5.0        | Upper Boundary     | EC2        | Testing the upper boundary value of the range (5.0)  <br> Method: testContainsUpperBoundary                    | True           | Pass        |
| TC5     | 6.0        | Above Upper Bound  | EC3        | Testing value just above the upper boundary of the range (5.0) <br>Method: testContainsAboveRange           | False          | Pass        |



## Method tested: **_getLength()_**

### Equivalence Class Partitioning

- EC1 – Normal range (lower < upper)

- EC2 – Zero-length range (lower = upper)

- EC3 – Reverse/invalid range (lower > upper)

- EC4 – Range spanning negative to positive

- EC5 – Very large range

| TC - ID | Range Start | Range End | Partitions Covered     | Scenario Description & Method                                                   | Expected Length | Test Outcome |
|:--------|:-----------:|:---------:|:---------------|---------------------------------------------------------------------------|:---------------:|:------------:|
| TC1     | 1.0         | 5.0       | EC1            | Standard range with distinct start and end values <br>Method: testGetLength                      | 4.0             | Pass         |
| TC2     | 1.0         | 1.1       | EC1            | Small range with a tiny difference between the start and end<br> Method: testGetLengthSmallRange           | 0.1             | Pass         |
| TC3     | 1.0         | 1000000.0 | EC1, EC5       | Large range with a large difference between the start and end  <br>Method: testGetLengthLargeRange         | 999999.0        | Pass         |
| TC4     | 5.0         | 5.0       | EC2            | Zero-length range (same start and end)    <br>Method: testGetLengthZeroRange                 | 0.0             | Pass         |
| TC5     | -5.0        | 5.0       | EC1, EC4       | Range spanning both negative and positive values   <br>Method: testGetLengthNegativeToPositive                       | 10.0            | Pass         |


## Method tested: **_getCentralValue()_**

### Equivalence Class Partitioning

- EC1 – Normal range (lower < upper)  
- EC2 – Zero-length range (lower = upper)  
- EC3 – Reverse/invalid range (lower > upper)  
- EC4 – Range spanning negative to positive  
- EC5 – Very large range  

| TC - ID | Range Start | Range End | Partitions Covered     | Scenario Description & Method                                                                | Expected Central Value | Test Outcome |
|---------|------------|-----------|---------------|--------------------------------------------------------------------------------------|-----------------------|-------------|
| TC1     | 1.0        | 5.0       | EC1           | Standard range with a well-defined central value   <br>Method:  testGetCentralValue                            | 3.0                   | Pass        |
| TC2     | 1.0        | 1.1       | EC1           | Very small range where central value is halfway between start and end  <br>Method: testGetCentralValueSmallRange        | 1.05                  | Pass        |
| TC3     | 5.0        | 5.0       | EC2           | Zero-length range where the central value is just the value itself     <br>Method: testGetCentralValueZeroRange        | 5.0                   | Pass        |
| TC4     | -5.0       | 5.0       | EC1, EC4      | Range that spans both negative and positive values, central value should be zero <br>Method:testGetCentralValueNegativeToPositive  | 0.0                   | Pass        |
| TC5     | 1.0        | 1000000.0 | EC1, EC5      | Very large range, central value should be the average of the start and end values <br>Method:testGetCentralValueLargeRange  | 500000.5              | Pass        |
| TC6     | 5.0        | 1.0       | EC3           | Reverse boundaries; central value should still be the average              <br>Method:testGetCentralValueReverseRange        | 3.0            | Error |


## Method tested: **_getUpperBound()_**

### Equivalence Class Partitioning

- EC1 – Normal range (lower < upper)  
- EC2 – Zero-length range (lower = upper)  
- EC3 – Reverse/invalid range (lower > upper)  
- EC4 – Range spanning negative to positive  
- EC5 – Very large range  

| TC - ID | Range Start | Range End | Partitions Covered     | Scenario Description & Method                                                      | Expected Upper Bound | Test Outcome |
|---------|------------|-----------|---------------|------------------------------------------------------------------------------|---------------------|-------------|
| TC1     | 1.0        | 5.0       | EC1           | Standard range with the upper bound clearly defined  <br>Method: testUpperBound                      | 5.0                 | Fail        |
| TC2     | 5.0        | 5.0       | EC2           | Zero-length range where the upper bound is the same as the start value <br>Method:testUpperBoundZeroLengthRange       | 5.0                 | Pass        |
| TC3     | -5.0       | 5.0       | EC1, EC4      | Range spanning negative and positive values, upper bound should be 5  <br>Method:testUpperBoundNegativeToPositiveRange       | 5.0                 | Fail        |
| TC4     | 1.0        | 1000000.0 | EC1, EC5      | Very large range where the upper bound is 1000000  <br>Method:testUpperBoundLargeRange                          | 1000000.0           | Fail        |
| TC5     | 5.0        | 1.0       | EC3           | Reverse boundaries (invalid range where lower > upper) <br>Method:testUpperBoundReverseRange                      | 5.0          | Error  |

## Method tested: **_getLowerBound()_**

### Equivalence Class Partitioning

- EC1 – Normal range (lower < upper)  
- EC2 – Zero-length range (lower = upper)  
- EC3 – Reverse/invalid range (lower > upper)  
- EC4 – Range spanning negative to positive  
- EC5 – Very large range  

| TC - ID | Range Start | Range End | Partitions Covered     | Scenario Description & Method                                   | Expected Lower Bound | Test Outcome |
|---------|------------|-----------|---------------|-----------------------------------------------------------|---------------------|-------------|
| TC1     | 1.0        | 5.0       | EC1           | Standard range with the lower bound clearly defined <br>Method: testLowerBound      | 1.0                 | Pass        |
| TC2     | 5.0        | 5.0       | EC2           | Zero-length range   <br>Method: testLowerBoundZeroLengthRange                                      | 5.0                 | Pass        |
| TC3     | -5.0       | 5.0       | EC1, EC4      | Range spanning negative and positive values  <br>Method: testLowerBoundNegativeToPositiveRange            | -5.0                | Pass        |
| TC4     | 1.0        | 1000000.0 | EC1, EC5      | Very large range <br>Method:  testLowerBoundLargeRange                                       | 1.0                 | Pass        |
| TC5     | 5.0        | 1.0       | EC3           | Reverse boundaries (invalid input: lower > upper)  <br>Method:  testLowerBoundReverseRange     | 1.0           | Error  |

## Test Case Summary 

contains(): All boundary and inside range tests passed as expected. The method correctly identified values that were outside the range, as well as those that were on the boundaries and inside. 

getLength(): The length was calculated correctly for typical ranges, as well as for small and large ranges. The edge case with zero-length ranges was also handled correctly. 

getCentralValue(): The central value calculation was correct across a variety of ranges, including those that span both negative and positive values. 

getLowerBound(): The tests confirmed that the Range class correctly returns the lower bounds of any valid range, including ranges where the upper and lower bounds are the same (zero-length ranges). 

getUpperBound(): 

The tests confirmed that the Range class does not always return the correct upper bound for certain ranges. Specifically, the method fails in some cases, as seen in test cases TC1, TC3, and TC4, where the expected upper bound was not returned correctly. 

Bug Analysis: Upon closer examination, it appears there is a bug in the getUpperBound() method. The method is expected to return the upper bound of a range as a double, but in some cases, particularly when dealing with large ranges or edge cases, the value is not being returned as expected. 

Potential Cause: The issue might be due to incorrect handling of certain edge cases or a rounding error when calculating the upper bound. It’s also possible that the method does not account for ranges with extreme values (like very large or small numbers). 

Example Failures: 

Test Case TC1 (range from 1.0 to 5.0): Expected upper bound is 5.0, but the method failed to return it correctly. 

Test Case TC3 (range from -5.0 to 5.0): Expected upper bound is 5.0, but the method failed to return it correctly. 

Test Case TC4 (range from 1.0 to 1000000.0): Expected upper bound is 1000000.0, but the method failed to return it correctly. 

Impact of the Bug: This bug affects the accuracy of any functionality that relies on the upper bound of a range. For instance, operations like checking whether a value is within the upper limit of a range, or adjusting the range dynamically, may not work as intended. 

Next Steps: It is important to address this bug by reviewing the method’s implementation. We recommend investigating the logic for handling large values and ensuring that the method returns the correct upper bound value across all test cases. A potential fix might involve improving how the method handles boundary conditions or implementing additional checks for large or small values. 

## DataUtilities

We used Mocks for calculateColumnTotal, calculateRowTotal, and getCumulativePercentages because they rely on interfaces (Values2D and KeyedValues). We did not use mocks for createNumberArray and createNumberArray2D because they operate on primitive arrays, which have no behavior to mock and can be tested directly with concrete values.

### calculateColumnTotal & calculateRowTotal

Domain Derivation:
- data: object implementing the Values2D interface
- column/row: zero-based integer index

Equivalence Classes:
- data:
  - EC1: Valid non-null Values2D
  - EC2: Null Values2D
  - EC3: Values2D with some null cells
- column/row:
  - EC4: column/row < 0
  - EC5: 0 <= column/row < columnCount/rowCount
  - EC6: column/row >= columnCount/rowCount
 
Boundary Value Analysis: 
- BLB: -1
- LB: 0
- BUB: columnCount/rowCount - 1
- UB: columnCount/rowCount

### createNumberArray

Domain Derivation: 
- data: 1D array of double numbers

Equivalence Classes:
- EC1: valid non-null array
- EC2: null array
- EC3: empty array
- EC4: mixed negative/positive values
- EC5: contains NaN/Infinity

BVA: N/A

### createNumberArray2D

Domain Derivation: 
- data: 2D array of double numbers

Equivalence Classes:
- EC1: valid non-null rectangular 2D array
- EC2: null outer array
- EC3: contains null inner row
- EC4: empty outer array
- EC5: some empty inner rows
- EC6: contains NaN/Infinity

BVA: N/A

### getCumulativePercentages

Domain Derivation: 
- data: object implementing the KeyedValues (ordered list of key-value pairs) interface

Equivalence Classes:
- EC1: valid non-null with positive values
- EC2: null data
- EC3: data contains zeros
- EC4: data contains negative values
- EC5: data contains null item values
- EC6: data with sum of all values as zero

BVA: N/A

### Robustness

Special cases covered in the ECs above:
- Null objects/values
- Empty values
- NaN/Infinity values
- Zero divisor (when sum of all values is zero)

### Discussion on Mocking

Pros:
- Unit isolation: By mocking the Values2D or KeyedValues interfaces, we know that a bug is inside DataUtilities, not caused by a defect in Values2D or KeyedValues.
- Control over test scenarios and edge cases: For example, when testing how DataUtilities handles negative index, we can easily instruct the mock object to return those exact values when getValue() is called.
- Simplifies setup process: We do not have to create Values2D and KeyedValues objects for testing.

Cons:
- Vulnerable to interface changes: Every test case may break if the interface methods are changed in the future.
- Vulnerable to implementation changes: Expectations may break if the DataUtilities methods are changed or optimized in the future.


## DataUtilities Test Cases

| Method Tested        | Test Method Name                                  | Partitions Covered |
|----------------------|---------------------------------------------------|--------------------|
| calculateColumnTotal | calculateColumnTotalForTwoValuesWithLBColumn      | EC1 + EC5 (LB) |
| calculateColumnTotal | calculateColumnTotalForNull                       | EC2  |
| calculateColumnTotal | calculateColumnTotalForValuesWithNullAndBUBColumn | EC3 + EC5 (BUB) |
| calculateColumnTotal | calculateColumnTotalForBLBColumn                  | EC4 (BLB) |
| calculateColumnTotal | calculateColumnTotalForUBColumn                   | EC6 (UB) |
||||
| calculateRowTotal    | calculateRowTotalForTwoValuesWithLBRow            | EC1 + EC5 (LB) |
| calculateRowTotal    | calculateRowTotalForNull                          | EC2  |
| calculateRowTotal    | calculateRowTotalForValuesWithNullAndBUBRow       | EC3 + EC5 (BUB) |
| calculateRowTotal    | calculateRowTotalForBLBRow                        | EC4 (BLB) |
| calculateRowTotal    | calculateRowTotalForUBRow                         | EC6 (UB) |
||||
| createNumberArray    | createNumberArrayWithValidData                    | EC1 |
| createNumberArray    | createNumberArrayForNull                          | EC2 |
| createNumberArray    | createNumberArrayWithEmptyArray                   | EC3 |
| createNumberArray    | createNumberArrayWithMixedValues                  | EC4 |
| createNumberArray    | createNumberArrayWithSpecialValues                | EC5 |
||||
| createNumberArray2D  | createNumberArray2DWithValidData                  | EC1 |
| createNumberArray2D  | createNumberArray2DForNull                        | EC2 |
| createNumberArray2D  | createNumberArray2DWithNullInnerRow               | EC3 |
| createNumberArray2D  | createNumberArray2DWithEmptyOuterArray            | EC4 |
| createNumberArray2D  | createNumberArray2DWithEmptyInnerRow              | EC5 |
| createNumberArray2D  | createNumberArray2DWithSpecialValues              | EC6 |
||||
| getCumulativePercentages | getCumulativePercentagesForPositiveValues     | EC1 |
| getCumulativePercentages | getCumulativePercentagesForNull               | EC2 |
| getCumulativePercentages | getCumulativePercentagesForDataContainsZero   | EC3 |
| getCumulativePercentages | getCumulativePercentagesForDataContainsNegative | EC4 |
| getCumulativePercentages | getCumulativePercentagesForDataContainsNull   | EC5 |
| getCumulativePercentages | getCumulativePercentagesForDataSumIsZero      | EC6 |

# 3. How the team work/effort was divided and managed

Our team of four divided the work by class: two members worked on testing the Range class and two on DataUtilities class. To stay on track with the assignment deadline we had regular meetings to know how best we are progressing , conducted peer reviews to ensure consistency and quality in our test cases.

## Work distribution
| Members           | Class/Focus        | Tasks                                                                 |
|------------------|------------------|-------------------------------------------------------------------------------|
| Zhanzi, Joe | DataUtilitiesTest          | Review the DataUtilities class in the Javadoc and use equivalence classes, boundary value analysis, and robustness testing to create black-box test cases for the 5 methods. Then, run the tests using JUnit and document the results and outcome of each test case. |
| Kwesi, Lawrence | RangeTest | Review the Rangeclass in the Javadoc and use equivalence classes, boundary value analysis, and robustness testing to create black-box test cases for 5 chosen methods. Then, run the tests using JUnit and document the results and outcome on each test case. |

# 4. Difficulties encountered, challenges overcome, and lessons learned
## The difficulties encountered
- When testing functions like getLength() and getCentralValue(), you need to provide a delta value in assertEquals to compare double values. Because of how Java stores floating-point numbers, some decimal values can't be saved exactly. Tests may not pass even if the implementation is right because of this. Choosing the right tolerance value (like 0.0001) makes sure to guarantee that minor rounding errors do not cause false test failures while still detecting real calculation issues.
- Strict setup on JMock, especially for expectations.
- Ambiguous documentation: For calculateColumnTotal and calculateRowTotal, both 'with invalid input, a total of zero will be returned' and 'Throws: InvalidParameterException - if invalid data object is passed in' are stated in the Javadoc. We can only assume that the first one implies the row and column inputs, while the second one refers to invalid Values2D data (like null).
-  We discovered that the Range constructor requires the lower bound as the first argument and the upper bound as the second. This initially caused confusion when we attempted to implement equivalent classes, particularly when handling invalid inputs where the bounds were reversed or improperly defined.
 
 ## Challenges Overcome
 - Using flexible expectations (like 'allowing') to overcome the strictness of the mocking framework.
 - When testing ranges where the lower and upper bounds were the same or reversed, it was important to be careful to ensure correct results.
 ## Lessons Learned
 -  We learnt out that it is necessary to test unusual cases, like zero-length ranges with or boundaries that go backwards, to make sure the program works in all situations.
 -  Organized Testing: Writing one clear test for each situation makes it easier to keep track of which test cases pass or fail.



# 5. Comments/feedback on the lab itself

The lab was well-structured and set up in a way to introduce us to JUnit for automated unit testing. The step-by-step instructions , which started out with setting up of the project , configuring the libraries and getting to know about the JFreeChart framework , made it easy for us to acquire some hands-on experience. Using Javadoc as a source of requirement enabled us to derive test cases from specifications which is essential in black-box testing.

This lab helped greatly to understand JUnit and unit testing procedures, with regard to organization and documentation of each test case's objective. We had to carefully examine each method's intended behaviour in order to write assertions with expeccted results. 
