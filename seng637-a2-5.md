**SENG 637 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group \#:      | 5   |
| -------------- | --- |
| Student Names: |     |
| Lawrence Lamptey               |     |
| Kwesi Ansu-Kyeremeh            |     |
|                |     |

# 1 Introduction

In this lab, we performed unit testing on the Range class and DataUtilities from the JFreeChart library. The Range class encapsulates a range of numeric values and provides several methods to query whether a value is contained within the range, calculate the length of the range, and determine the central value, upper, and lower bounds.

Additionally, we tested the DataUtilities class, which provides utility methods for managing and manipulating datasets in JFreeChart. Both classes are integral to handling numerical data and performing various range-based operations.

The primary objective of this testing was to ensure the correctness of the methods in both classes through Boundary Value Analysis (BVA) and Equivalence Class Partitioning (ECP). These methods were tested to confirm that each function behaves as expected across a variety of test cases, ensuring reliable and accurate functionality for data manipulation and range operations.

# 2 Detailed description of unit test strategy
Our testing strategy for the RangeTest class was based on ; 
- Equivalence Class Partitioning
- Boundary Value Analysis
- Robustness Testing (negative, zero, and large values)

The base range for testing the unit cases was given as 1 to 5.
The range provided the basis for creating valid, invalid, and boundary test scenarios.

- Equivalence Class Partitioning
  
Equivalence Class Partioning(ECP) was used to categorize input values into groups as a way of verifying the systems behaviour for each of the  classes effectively.

The input domain for the contains( double value) method was categorized into three equivalence classes;
-  EC1 (Invalid Range – Below Lower Bound): value < 1
-  EC2 (Valid Range): 1 ≤ value ≤ 5
-  EC3 (Invalid – Above Upper Bound) value > 5

  We also checked the boundary values of 1.0 and 5.0 to make sure that the mrthod includes the range's bounds. This helps find errors in how the program checks values.

For methods like getLength() and getCentralValue(), equivalence partitions were based on structural changes in the range itself instead of just one input value. These partitions included:
- Normal Valid Range
- Small Range
- Large Range
- Zero-length Range
- Negative to Positive Range
- Reverse Bounds
  

- Boundary Value Analysis: 
  We used Boundary Value Analysis to check for errors near the edge of the range. For the base range(1.0 , 5.0) we looked at the following boundary values;
  - Lower Boundary: 1.0
  - Upper Boundary: 5.0
  - Just Below Lower Boundary: 0.0
  - Just Above Upper Boundary: 6.0
    
These tests verify that the range includes both the lowest and highest values, excludes values beyond the range, and accurately assesses the boundaries. We also tested ranges when the lower and upper bounds are the same to make that the program runs when there is only one value in the range.

- Robustness Testing: We tested robustness with large numbers, minor decimal differences, zero-length ranges, negative-to-positive intervals, and reversed boundaries. These makes sure the program handles odd inputs without arithhmetic or logic errors




# 3 Test cases developed

Text…

// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

# 4 How the team work/effort was divided and managed

Text…

# 5 Difficulties encountered, challenges overcome, and lessons learned
The difficulties encountered
1. When testing functions like getLength() and getCentralValue(), you need to provide a delta value in assertEquals to compare double values. Because of how Java stores floating-point numbers, some decimal values can't be saved exactly. Tests may not pass even if the implementation is right because of this. Choosing the right tolerance value (like 0.0001) makes guarantee that minor rounding errors do not cause false test failures while still detecting real calculation issues.

# 6 Comments/feedback on the lab itself

This lab helped greatly to understand JUnit and unit testing procedures, with regard to organization and documentation of each test case's objective. We had to carefully examine each method's intended behaviour in order to write assertions with expeccted results. 
